.TH "KeyboardFunctions" 3 "Thu Feb 6 2020" "Version v1" "Herkulex_English" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KeyboardFunctions
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <KeyboardFunctions\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "char \fBgetNonBlockingTriggers\fP ()"
.br
.RI "Get non-blocking keyboard triggers (skip until triggered) "
.ti -1c
.RI "char \fBgetBlockingTriggers\fP ()"
.br
.RI "Get blocking keyboard triggers (wait until triggered) "
.ti -1c
.RI "void \fBdemo\fP ()"
.br
.RI "A test/demo of the linux kbhit function\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "int \fB_kbhit\fP ()"
.br
.RI "A Linux implementation of Windows _kbhit non-blocking function to wait for user's key pressed\&. "
.ti -1c
.RI "char \fB_getch\fP ()"
.br
.RI "A Linux implementation of Windows _getch to obtain the keypressed from the buffer\&. "
.in -1c
.SH "Detailed Description"
.PP 
Keyboard function class 
.br
 A implementation of the \fB_kbhit()\fP function for Linux\&. 
.br
In windows \fB_kbhit()\fP is suppose to implement non-blocking user input checking function\&. If the function returns a nonzero value, a keystroke is waiting in the buffer\&. The program can then call _getch or _getche to get the keystroke\&. 
.br
Non-blocking means that inputs can interrupt the current ongoing process, but not let the program wont wait for user input indefinitely like scanf
.PP
In Windows , conio\&.h implements the _kbhit function for us\&. 
.br
In Linux, we have to implement our own, because it lacks a _kbhit function\&. 
.PP
\fBSee also:\fP
.RS 4
http://www.flipcode.com/archives/_kbhit_for_Linux.shtml
.RE
.PP
\fBNote:\fP
.RS 4
within rpi, when using this function, we need to allow the user to run the internal script '/sys/class/gpio/export' in sudo mode\&. Hence, there is a need to elevate permission when running the code, or change permission of the export file\&. 
.br
1) elevate permission when running code: $ sudo \&./bin/ARM/Debug/RPi_VS_CrossplatformBuild\&.out\&. 
.br
2) change permission of export script: $ sudo chmod 777 /sys/class/gpio/export
.RE
.PP
\fBAuthor:\fP
.RS 4
Er Jie Kai (EJK)
.RE
.PP
Edited from the source written by the following 
.PP
\fBAuthor:\fP
.RS 4
Morgan McGuire, morgan@cs.brown.edu 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "char KeyboardFunctions::_getch ()\fC [private]\fP"

.PP
A Linux implementation of Windows _getch to obtain the keypressed from the buffer\&. 
.PP
\fBReturns:\fP
.RS 4
the ascii keystroke 
.RE
.PP

.SS "int KeyboardFunctions::_kbhit ()\fC [private]\fP"

.PP
A Linux implementation of Windows _kbhit non-blocking function to wait for user's key pressed\&. 
.PP
\fBReturns:\fP
.RS 4
number of bytes waiting in the buffer\&. 
.RE
.PP

.SS "void KeyboardFunctions::demo ()"

.PP
A test/demo of the linux kbhit function\&. Calling this function will run a non-blocking keyboard detection loop\&.
.br
Once the 'E' key is pressed, the program will stop\&.
.PP
\fBNote:\fP
.RS 4
this demo should run on both linux and windows\&.
.RE
.PP
\fBReturns:\fP
.RS 4
returns nothing 
.RE
.PP

.SS "char KeyboardFunctions::getBlockingTriggers ()"

.PP
Get blocking keyboard triggers (wait until triggered) Calling this function will block the program using a while(1) loop\&. 
.br
Will only return when a keyboard is pressed/triggered
.PP
Trigger Code: 
.br
-look at the define pre-compiled macros defined in header file
.PP
\fBReturns:\fP
.RS 4
returns the trigger code 
.RE
.PP

.SS "char KeyboardFunctions::getNonBlockingTriggers ()"

.PP
Get non-blocking keyboard triggers (skip until triggered) Calling this function will NOT block the program 
.br
return the triggered code
.PP
Trigger Code: 
.br
-look at the define pre-compiled macros defined in header file
.PP
\fBReturns:\fP
.RS 4
returns the trigger code 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Herkulex_English from the source code\&.
